package org.sofa.gfx.mesh

import scala.language.implicitConversions

import org.sofa.FileLoader
import org.sofa.nio._
import org.sofa.gfx._
import org.sofa.gfx.io.collada.ColladaFile

import scala.collection.mutable.HashMap



/** A mesh that can reference multiple elements arrays in the same vertex attribute set.
  *
  * The OpenGL vocabulary talks about:
  *   - Array buffers, they store vertex attribute values (vertex position, color, normal, etc.)
  *   - Element buffers, they are arrays of integers pointing inside array buffers to tell
  *     how to draw primitives from the array buffer.
  *   - Vertex arrays, a grouping between several array buffers, one element buffer allowing
  *     to quickly bind in one call several array buffers and the element buffer.
  *
  * A multi-mesh works like a mesh, but it provides several elements arrays that point into
  * an unique set of shared vertex attributes allowing to draw several kinds of primitives,
  * drawn from the same set of vertex attributes. Inside this class, we call these multiples
  * elements arrays sub-meshes.
  *
  * Such a mesh also provides several vertex arrays instead of one, each one being associated to
  * a distinct sub-mesh. */
trait MultiMesh extends Mesh {
	import VertexAttribute._

	/** Last produced vertex arrays, one for each elements array. The [[va]] field is the
	  * last created vertex array stored in this. */
	protected[this] var vas:Array[VertexArray] = _

	/** The shaders used to allocate each vertex array. */
	protected[this] var shs:Array[ShaderProgram] = _

	/** List of already allocated array buffers for all the vertex arrays. The array buffers store
      * vertex attribute data. They are shared between all the vertex arrays generated by this mesh. */
	protected[this] val arrayBuffers = new HashMap[String, ArrayBuffer]()

	/** Release the resources of this mesh, the mesh is no more usable after this. */
	override def dispose() { if(vas ne null) vas.foreach { _.dispose } }

	/** Number of vertices in the mesh. */
	def vertexCount:Int

	override def elementsPerPrimitive:Int = elementsPerPrimitive(0)

	/** Number of elements per primitive for the given `subMesh`. Each sub mesh may have
	  * a distinct draw mode, therefore it needs more or less elements.
	  * The original `elementPerPrimitive()` method returns the elements per
	  * primitive of the first sub mesh. */
	def elementsPerPrimitive(subMesh:Int):Int

    /** Elements indices in the attributes array for the given `subMesh`. */
    def elements(subMesh:Int):IntBuffer = throw new InvalidPrimitiveException("no elements in this mesh")
    
    /** True if the mesh has indexes in the vertex attributes to define primitives. */
    def hasIndices():Boolean = subMeshCount > 0

    /** Number of sub meshes. */
    def subMeshCount:Int 

    override def drawAs(gl:SGL) = drawAs(gl, 0)

    /** How to draw the `subMesh` (as points, lines, lines loops, triangles, etc.).
      * This depends on the way the data is defined. The original `drawAs()` method 
      * returns the draw method of the first sub mesh. */
    def drawAs(gl:SGL, subMesh:Int):Int

    override def draw(gl:SGL) = drawSubMesh(gl, 0)

    /** Draw the last vertex array created for `subMesh`. If no vertex array has been created
      * for this sub mesh, a `NoVertexArrayException` is thrown. This uses the `drawAs()`
      * method to select how to draw the sub mesh (triangles, points, etc.). */
    def drawSubMesh(gl:SGL, subMesh:Int) {
    	if(vas ne null)
    		vas(subMesh).draw(drawAs(gl, subMesh)) 
    	else throw new NoVertexArrayException("create vertex arrays for sub meshes before draw")
    }

    override def draw(gl:SGL, count:Int) = drawSubMesh(gl, 0, count)

    /** Draw the `count` first primitives the last vertex array created for `subMesh`. A
      * primitive is a line or triangle for example, it depends on the kind of sub mesh.
      * If no vertex array has been created for `subMesh, a `NoVertexArrayException` is thrown.
      * This uses the `drawAs()` method to select
      * how to draw the sub mesh (triangles, points, etc.), and the `elementsPerPrimitive`
      * to know how many elements (vertices, colors) makes up a primitive. */
    def drawSubMesh(gl:SGL, subMesh:Int, count:Int) {
    	if(vas ne null)
    		vas(subMesh).draw(drawAs(gl, subMesh), count * elementsPerPrimitive(subMesh))
    	else throw new NoVertexArrayException("create vertex arrays for sub meshes before draw")
    }

    override def draw(gl:SGL, start:Int, count:Int) = drawSubMesh(gl, 0, start, count)

    /** Draw `count` primitives starting at `start` of the last vertex array created for 
      * `subMesh`. A primitive is a line or triangle for example, it depends on the
      * kind of sub mesh. If no vertex array has been created for `subMesh` a `NoVertexArrayException` is
      * thrown. This uses the `drawAs()` method to select how to draw the sub mesh
      * (triangles, points, etc.), and the `elementsPerPrimitive` to know how many
      * elements (vertices, colors) makes up a primitive. */
    def drawSubMesh(gl:SGL, subMesh:Int, start:Int, count:Int) {
    	if(va ne null) {
    		val epp = elementsPerPrimitive(subMesh)
    		vas(subMesh).draw(drawAs(gl, subMesh), start * epp, count * epp)
    	} else {
    		throw new NoVertexArrayException("create vertex arrays for sub meshes before draw")
    	}
    }
    
    override def toString():String = {
    	val attrs = attributes.map { item => (item, components(item)) }

    	"mesh(%s, attributes(%d) { %s })".format(
    		if(hasIndices) "sub meshes (%d)".format(subMeshCount) else "no sub mesh",
    		attributeCount,
    		attrs.mkString(", ")
    	)
    }

    /** The last created vertex array for `subMesh`.
      *
      * Each time a vertex array is created with for a sub mesh, it is remembered. Some
      * meshes allow to update the arrays when a change is made to the data in the
      * mesh. Such meshes are dynamic. */
    def vertexArray(subMesh:Int):VertexArray = vas(subMesh)

    /** True if at least one vertex array was created. You can access it using `lastva()`. */
    override def hasVertexArray:Boolean = ((vas ne null) && vas.length > 0)

    /** True if the given `subMesh` vertex array has been created. */
    def hasVertexArray(subMesh:Int):Boolean = ((vas ne null) && (vas(subMesh) ne null))

    /** The shader used to allocate the vertex array for `subMesh`. */
    def shader(subMesh:Int):ShaderProgram = shs(subMesh)

    /** Always called before creating a new vertex array for `subMesh`. Hook for sub-classes.
      * The original `beforeNewVertewArray()` is also called. */
    protected def beforeNewVertexArray(subMesh:Int) {}

    /** Always called after creating a new vertex array for `subMesh`. Hook for sub-classes.
      * The original `afterNewVertexArray()` is also called. */
    protected def afterNewVertexArray(subMesh:Int) {}

    /** Create a vertex array from the given map of attribute `locations` names to locations.
      * You can specify the draw mode for the array buffers, either STATIC_DRAW, STREAM_DRAW
      * or DYNAMIC_DRAW.
      * 
      * Example usage: newVertexArray(gl, gl.DYNAMIC_DRAW, ("vertices", 0), ("normals", 1))
	  *
      * The last created vertex array is remembered by the mesh and can be accessed later,
      * and for some meshes updated from new data if the mesh is dynamic. */
    def newSubMeshVertexArray(gl:SGL, subMesh:Int, drawMode:Int, shader:ShaderProgram, locations:Tuple2[String,String]*):VertexArray = {
    	beforeNewVertexArray()
    	beforeNewVertexArray(subMesh)

    	if(vas eq null) vas = new Array[VertexArray](subMeshCount)
    	if(shs eq null) shs = new Array[ShaderProgram](subMeshCount)

		val locs = new Array[Tuple3[String,Int,ArrayBuffer]](locations.size)
    	var pos  = 0

    	locations.foreach { value =>
    		val attribute   = value._1
    		val location    = shader.getAttribLocation(value._2)
    		val arrayBuffer = createOrReuseArrayBuffer(gl, attribute, drawMode)
    		locs(pos)       = (attribute, location, arrayBuffer)
    		pos += 1
    	}

    	shs(subMesh) = shader
    	vas(subMesh) = new VertexArray(gl, ElementBuffer(gl, elements(subMesh)), locs:_*)
    	va = vas(subMesh)
    	sh = shader

    	afterNewVertexArray(subMesh)
    	afterNewVertexArray()

    	vas(subMesh)
    }

    protected def createOrReuseArrayBuffer(gl:SGL, attr:String, drawMode:Int):ArrayBuffer = {
    	arrayBuffers.get(attr).getOrElse {
    		val buf = ArrayBuffer(gl, components(attr), attribute(attr), drawMode)
    		arrayBuffers += (attr -> buf)
    		buf
    	}
    }
}